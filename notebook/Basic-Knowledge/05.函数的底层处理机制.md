## 函数的底层处理机制

 ```javascript
var x = [12, 23] 
function fn(y) {
  y[0] = 100
  y = [100]
  y[1] = 200
  console.log(y) 
}
fn(x)
console.log(x)
 ```

- 第一步，浏览器开辟一块内存，执行环境栈**ECStack**
- 第二步，开辟一个全局执行环境，全局作用域**EC(G)**
- 第三步，在全局上下文中生成一个全局变量对象**VO(variable object global)**存放声明的变量
- 第四步，进栈执行
- 第五步，执行完出栈，释放内存

### 函数的创建

函数的创建和变量的创建区别不大，函数名就是变量名

1. 单独开辟一个堆内存「16进制地址」，函数堆内存中存储的是函数体的**“代码字符串”**（对象是存放键值对，函数是存放代码字符串）
2. 创建函数的时候，就声明了他的**作用域[scope]**，也就是所在的上下文环境(在哪创建的函数，它的作用域就是谁，比如在全局作用域下创建的函数，这个函数的作用域就是EC(G))
3. 把16进制的地址存放到栈中，供变量（函数名等）关联引用即可

### 函数的执行

函数在执行的时候，会把创建函数的时候在堆内存中存储的**字符串**变为代码执行；

1. 函数执行前会先形成一个全新的、私有的、执行上下文**EC(FN)**；

2. 在私有上下文中，也有存放自己变量的对象，叫（**AO Active Object 活动对象**）它是VO的一种，这里的变量都是当前上下文内的私有变量「当前上下文中声明的变量，形参变量」

3. 进栈执行

4. 代码执行之前还要处理很多事情

    1. 初始化**作用域链[socpe-chain]**，<当前自己的上下文，上级上下文（创建函数时候形成的作用域）-> **当前函数的上级上下文是创建函数所在的上下文（作用域）**>后期函数内代码执行，遇到一个变量，我们首先看是否为自己上下文中的私有变量（看AO当中有没有），如果是私有变量，则当前变量的操作和外界环境互不干扰，没有直接关系；如果不是自己的私有变量，则按照作用域链，查找是否为其上下文中的私有变量，直到找到EC(G)全局上下文为止（**作用域链查找机制**）
    2. 初始化this ...
    3. 初始化arguments ...
    4. 形参赋值：形参都是私有变量（放到AO中），如果没有传递实参，默认值是undefined ...
    5. 变量提升

5. 代码自上而下执行

6. 一般情况下，函数执行所形成的上下文，进栈执行完后，或默认的出栈释放掉，私有上下文中存储的私有变量和一直值都会被释放掉，目的是为了优化内存空间，减少栈内存的消耗，提高页面或者计算机的处理速度

    ......



### 代码分析

```javascript
var x = [12, 23] // x --- 0x001 [12, 23]
function fn(y) { // 创建函数，内存地址为0x002，在当函数执行时，传入实参，然后形参赋值，将y与堆内存地址关联 y --- 0x001
  y[0] = 100 // 0x001[0] = 100 => 0x001 = [100, 23]
  y = [100] // 开辟一个堆内存地址将[100]存储起来，内存地址为0x003，将形参y --- 0x003
  y[1] = 200 // 0x003[1] = 200 => 0x003 = [100, 200]
  console.log(y) // [100, 200]
}
fn(x)
console.log(x) // [100, 23]
```

